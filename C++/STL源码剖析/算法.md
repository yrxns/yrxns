- # unique_copy
    ```C++
    template <typename InputIterator, typename OutputInteraotr>
    inline OutputInteraotr unique_copy(InputIterator first, InputIterator last, OutputInteraotr result) {
        if (first == last)  return result;
        return __unique_copy(first, last, result, iterator_category(result));
    }

    template <typename InputIterator, typename ForwardInteraotr>
    ForwardInteraotr __unique_copy(InputIterator first, InputIterator last, ForwardInteraotr result, forward_iterator_tag) {
        *result = *first;
        while (++first != last) 
            if (*result != *first)  *++result = *first;
        return ++result;
    }

    template <typename InputIterator, typename OutputInteraotr>
    inline OutputInteraotr __unique_copy(InputIterator first, InputIterator last, OutputInteraotr result, output_iterator_tag) {
        return __unique_copy(first, last, result, value_type(first));
    }

    template <typename InputIterator, typename OutputInteraotr, typename T>
    OutputInteraotr __unique_copy(InputIterator first, InputIterator last, OutputInteraotr result, T*) {
        T value = *first;
        *result = value;
        while (++first != result) 
            if (value != *first) {
                value = *first;
                *++result = value;
            }
        return ++result;
    }
    ```

- # unique
    > 移除相邻的重复元素
    ```C++
    template <typename ForwardIterator>
    ForwardIterator unique(ForwardIterator first, ForwardIterator last) {
        first = adjacent_find(first, last);
        return unique_copy(first, last, first);
    }
    ```

- # transform
    ```C++
    //版本一
    template <typename InputIterator, typename OutputInteraotr, typename UnaryOperation>
    OutputInteraotr transform(InputIterator first, InputIterator last, OutputInteraotr result, UnaryOperation op) {
        for ( ; first != last; ++first, ++result)
            *result = op(*first);
        result result;
    }

    //版本二
    template <typename InputIterator1, typename InputIterator2, typename OutputInteraotr, typename BinaryPredicate>
    OutputInteraotr transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputInteraotr result, BinaryPredicate binary_op) {
        for ( ; first1 != last1; ++first1, ++first2, ++result)
            *result = binary_op(*first1, *first2);
        return result;
    }
    ```

- # swap_ranges
    ```C++
    template <typename ForwardIterator1, typename ForwardIterator2>
    ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2) {
        for ( ; first1 != last1; ++first1, ++first2)
            iter_swap(first1, first2);
        return first2;
    }
    ```

- # search_n
    ```C++
    //版本一
    template <typename ForwardIterator, typename Integer, typename T>
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Integer count, const T& value) {
        if (count < 0)
            return first;
        else {
            first = find(first, last, value);
            while (first != last) {
                Integer n = count -1;
                ForwardIterator i = first;
                ++i;
                while (i != last && n != 0 && *i == value) {
                    ++i;
                    --n;
                }
                if (n == 0)
                    return first;
                else {
                    first = find(i, last, value);
                }
            }
            return last;
        }
    }

    //版本二
    template <typename ForwardIterator, typename Integer, typename T, typename BinaryPredicate>
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Integer count, const T& value, BinaryPredicate binary_pred) {
        if (count < 0)
            return first;
        else {
            while (first != last) {
                if (binary_pred(*first, value)) break;
                ++first;
            }
            while (first != last) {
                Integer n = count -1;
                ForwardIterator i = first;
                ++i;
                while (i != last && n != 0 && binary_pred(*i, value)) {
                    ++i;
                    --n;
                }
                if (n == 0)
                    return first;
                else {
                    while (i != last) {
                        if (binary_pred(*i, value)) break;
                        ++i;
                    }
                    first = i;
                }
            }
            return last;
        }
    }
    ```

- # search
    > 序列一内查找序列二的首次出现点
    ```C++
    template <typename ForwardIterator1, typename ForwardIterator2>
    inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2) {
        return __search(first1, last1, first2, last2, distance_type(first1), distance(first2));
    }

    template <typename ForwardIterator1, typename ForwardIterator2, typename Distance1, typename Distance2>
    ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, Distance1*, Distance2*) {
        Distance1 d1 = 0;
        distance(first1, last1, d1);
        Distance2 d2 = 0;
        distance(first2, last2, d2);

        if (d1 < d2)    return last1;

        ForwardIterator1 current1 = first1;
        ForwardIterator2 current2 = first2;

        while (current2 != last2)
            if (*current1 == *current2) {
                ++current1;
                ++current2;
            } else {
                if (d1 == d2)
                    return last1;
                else {
                    current1 = ++first1;
                    current2 = first2;
                    --d1;
                }
            }
            return first1;
    }
    ```

- # rotate
    > 将 [first, middle) 内的元素与 [middle, last) 内的元素互换。{1234567}->{3456712}
    ```C++
    template <typename ForwardIterator>
    inline void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last) {
        if (first == middle || middle == last)  return;
        __rotate(first, middle, last, distance_type(first), iterator_category(first));
    }

    template <typename ForwardIterator, typename Distance>
    void __rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last, Distance*, forward_iterator_tag) {
        for (ForwardIterator i = middle; ; ) {
            iter_swap(first, i);
            ++first;
            ++i;
            if (first == middle) {
                if (i == last) return;
                middle = i;
            }
            else if (i == last)
            i = middle;
        }    
    }

    template <typename BidirectionalIterator, typename Distance>
    void __rotate(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance*, bidirectional_iterator_tag) {
        reverse(first, middle);
        reverse(middle, last);
        reverse(first, last);
    }
    ```

- # reverse_copy
    ```C++
    template <typename BidirectionalIterator, typename OutputIterator>
    OutputIterator reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result) {
        while (first != last) {
            --last;
            *result = *first;
            ++result;
        }
        return result;
    }
    ```

- # reverse
    ```C++
    template <typename BidirectionalIterator>
    inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {
        __reverse(first, last, iterator_category(first));
    }

    template <typename BidirectionalIterator>
    inline void __reverse(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag) {
        while (true)
            if (first == last || first == --last)
                return;
            else
                iter_swap(first++, last);
    }

    template <typename RandomAccessIterator>
    void __reverse(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) {
        while (first < last) iter_swap(first++, --last);
    }
    ```

- # replace_if
    ```C++
    template <typename ForwardIterator, typename Predicate, typename T>
    void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value) {
        for ( ; first != last; ++first)
            if (pred(*first))    *first = new_value;
    }
    ```

- # replace_copy_if
    ```C++
    template <typename InputIterator, typename OutputIterator, typename Predicate, typename T>
    OutputIterator replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value) {
        for ( ; first != last; ++first, ++result)
            *result = pred(*first) ? new_value : *first;
        return result;
    }
    ```

- # replace_copy
    ```C++
    template <typename InputIterator, typename OutputIterator, typename T>
    OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T& old_value, const T& new_value) {
        for ( ; first != last; ++first, ++result)
            *result = *first == old_value ? new_value : *first;
        return result;
    }
    ```

- # replace
    ```C++
    template <typename ForwardIterator, typename T>
    void replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value) {
        for ( ; first != last; ++first)
            if (*first == old_value)    *first = new_value;
    }
    ```

- # remove_copy_if
    ```C++
    template <typename InputIterator, typename OutputIterator, typename Predicate>
    OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred) {
        for ( ; first != last; ++first) 
            if (!pred(*first)) {
                *result = *first;
                ++result;
            }
        return result;
    }
    ```

- # remove_if
    ```C++
    template <typename ForwardIterator, typename Predicate>
    ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, Predicate pred) {
        first = find_if(first, last, pred);
        ForwardIterator next = first;
        return first == last ? first : remove_copy_if(++next, last, first, pred);
    }
    ```

- # remove_copy
    ```C++
    template <typename InputIterator, typename OutputIterator, typename T>
    OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value) {
        for ( ; first != last; ++first)
            if (*first != value) {
                *result = *first;
                ++result;
            }
            return result;
    }
    ```

- # remove
    ```C++
    template <typename ForwardIterator, typename T>
    ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T& value) {
        first = find(first, last, value);
        ForwardIterator next = first;
        return first == last ? first : remove_copy(++next, last, first, value);
    }
    ```

- # partition
    > 重新排列序列中的元素，为 true 的元素放到序列的前端，false 的元素放到后端。
    ```C++
    template <typename BidirectionalIterator, typename Predicate>
    BidirectionalIterator partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred) {
        while (true) {
            while (true) {
                if (first == last)  
                    return first;
                else if (pred(*first))
                    ++first;
                else
                    break;
            }
            --last;
            while (true) {
                if (first == last)
                    return first;
                else if (!pred(*last))
                    --last;
                else
                    break;
            }
            iter_swap(first, last);
            ++first;
        }
    }
    ```

- # find_first_of
    > 以序列二中的元素为查找目标，寻找它们在序列一中第一次出现的地点
    ```C++
    //版本一
    template <typename InputIterator, typename ForwardInterator>
    InputIterator find_first_of(InputIterator first1, InputIterator last1,
                                ForwardInterator first2, ForwardInterator last2) {
        for ( ; first1 != last1; ++first1) 
            for (ForwardInterator iter = first2; iter != last2; ++iter)
                if (*first1 == *iter)
                    return first1;
        return last1;
    }

    //版本二
    template <typename InputIterator, typename ForwardInterator, typename BinaryPredicate>
    InputIterator find_first_of(InputIterator first1, InputIterator last1,
                                ForwardInterator first2, ForwardInterator last2,
                                BinaryPredicate comp) {
        for ( ; first1 != last1; ++first1) 
            for (ForwardInterator iter = first2; iter != last2; ++iter)
                if (comp(*first1, *iter))
                    return first1;
        return last1;
    }
    ```

- # for_each
    > 不可以改变元素内容
    ```C++
    template <typename InputIterator, typename Function>
    Function for_each(InputIterator first, InputIterator last, Function f) {
        for ( ; first != last; ++first)
            f(*first);
        return f;
    }
    ```

- # generate
    > 将仿函数gen的运算结果填写到序列中的所有元素身上
    ```C++
    template <typename ForwardInterator, typename Generator>
    void generate(ForwardInterator first, ForwardInterator last, Generator gen) {
        for ( ; first != last; ++first)
            *first = gen();
    }
    ```

- # generate_n
    > 将仿函数gen的运算结果填写到序列中从first开始的n个元素身上
    ```C++
    template <typename OutputInterator, typename Size, typename Generator>
    OutputInterator generate_n(OutputInterator first, Size n, Generator gen) {
        for ( ; n > 0; --n, +_+first)
            *first = gen();
        return first;
    }
    ```

- # includes(应用于有序区间)
    > 判断序列一是否包含序列二的全部元素
    ```C++
    //版本一
    template <typename InputIterator1, typename InputIterator2>
    bool includes(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2) {
        while (first1 != last1 && first2 != last2) 
            if (*first2 < *first1)
                return false;
            else if (*first1 < *first2) 
                ++first1;
            else 
                ++first1, ++first2;
        
        return first2 == last2;
    }

    //版本二
    template <typename InputIterator1, typename InputIterator2, typename Compare>
    bool includes(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                Compare comp) {
        while (first1 != last1 && first2 != last2) 
            if (comp(*first2, *first1))
                return false;
            else if (comp(*first1, *first2)) 
                ++first1;
            else 
                ++first1, ++first2;
        
        return first2 == last2;
    }
    ```

- # max_element
    ```C++
    //版本一
    template <typename ForwardInterator>
    ForwardInterator max_element(ForwardInterator first, ForwardInterator last) {
        if (first == last)  return first;
        ForwardInterator result = first;
        while (++first != last)
            if (*result < *first)   result = first;
        return result;
    }

    //版本二
    template <typename ForwardInterator, typename Compare>
    ForwardInterator max_element(ForwardInterator first, ForwardInterator last, Compare comp) {
        if (first == last)  return first;
        ForwardInterator result = first;
        while (++first != last)
            if (comp(*result, *first))   result = first;
        return result;
    }
    ```

- # min_element
    ```C++
    //版本一
    template <typename ForwardInterator>
    ForwardInterator min_element(ForwardInterator first, ForwardInterator last) {
        if (first == last)  return first;
        ForwardInterator result = first;
        while (++first != last)
            if (*first < *result)   result = first;
        return result;
    }

    //版本二
    template <typename ForwardInterator, typename Compare>
    ForwardInterator min_element(ForwardInterator first, ForwardInterator last, Compare comp) {
        if (first == last)  return first;
        ForwardInterator result = first;
        while (++first != last)
            if (comp(*first, *result))   result = first;
        return result;
    }
    ```

- # merge(应用于有序区间)
    > 将两个序列合并起来置于第三序列
    ```C++
    //版本一
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator>
    OutputInterator merge(InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputInterator result) {
        while (first1 != last1 && first2 != last2) {
            if (*first2 < *first1) {
                *result = *first2;
                ++first2;
            } else {
                *result = *first1;
                ++first1;
            }
            ++result;
        }
        return copy(first2, last2, copy(first1, last1, result));
    }

    //版本二
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator, typename Compare>
    OutputInterator merge(InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputInterator result, Compare comp) {
        while (first1 != last1 && first2 != last2) {
            if (comp(*first2, *first1)) {
                *result = *first2;
                ++first2;
            } else {
                *result = *first1;
                ++first1;
            }
            ++result;
        }
        return copy(first2, last2, copy(first1, last1, result));
    }
    ```

- # find_end
    > 在序列一中查找序列二的最后一次出现点。
    ```C++
    template <typename ForwardInterator1, typename ForwardInterator2>
    inline ForwardInterator1 find_end(ForwardInterator1 first1, ForwardInterator1 last1,
                                    ForwardInterator2 first2, ForwardInterator2 last2) {
        using category1 = typename iterator_traits<ForwardInterator1>::iterator_category;
        using category2 = typename iterator_traits<ForwardInterator2>::iterator_category;
        return __find_end(first1, last1, first2, last2, category1(), category2());
    }

    //以下是forward iterators 版
    template <typename ForwardInterator1, typename ForwardInterator2>
    ForwardInterator1 __find_end(ForwardInterator1 first1, ForwardInterator1 last1,
                                ForwardInterator2 first2, ForwardInterator2 last2,
                                forward_iterator_tag, forward_iterator_tag) {
        if (first1 == last1)    return last1;
        else {
            ForwardInterator1 result = last1;
            while (1) {
                ForwardInterator1 new_result = search(first1, last1, first2, last2);
                if (new_result == last1)    return result;
                else {
                    result = new_result;
                    first1 = new_result;
                    ++first1;
                }
            }
        }
    }

    //以下是 bidirectional iterators 版（可以逆向查找）
    template <typename BidirectionalIterator1, typename BidirectionalIterator2>
    BidirectionalIterator1 __find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,
                                    BidirectionalIterator2 first2, BidirectionalIterator2 last2,
                                    bidirectional_iterator_tag, bidirectional_iterator_tag) {
        //反向查找。利用 reverse_iterator
        using reviter1 = reverse_iterator<BidirectionalIterator1>;
        using reviter2 = reverse_iterator<BidirectionalIterator2>;
        reviter1 rlast1(first1);
        reviter2 rlast2(first2);
        //查找时，将序列一和序列二统统逆转方向
        reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2);
        if (rresult == rlast1)  return last1;
        else {
            BidirectionalIterator1 result = rresult.base(); //转回正常（非逆向）迭代器
            advance(result, -distance(first2, last2));  //调整为子序列的起始处
            return result;
        }
    }
    ```

- # count
    > 返回与指定值value相等的元素的个数
    ```C++
    template <typename InputIterator, typename T>
    typename iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const T& value) {
        typename iterator_traits<InputIterator>::difference_type n = 0;
        for ( ; first != last; ++first)
            if (*first == value)
                ++n;
        return n;
    }
    ```

- # count_if
    ```C++
    template <typename InputIterator, typename Predicate>
    typename iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred) {
        typename iterator_traits<InputIterator>::difference_type = 0;
        for ( ; first != last; ++first)
            if (pred(*first))
                ++n;
        return n;
    }
    ```

- # find
    ```C++
    template <typename InputIterator, typename T>
    InputIterator find(InputIterator first, InputIterator last, const T& value) {
        while (first != last && *first != value)    ++first;
        return first;
    }
    ```

- # find_if
    ```C++
    template <typename InputIterator, typename Predicate>
    InputIterator find(InputIterator first, InputIterator last, Predicate pred) {
        while (first != last && !pred(*first))    ++first;
        return first;
    }
    ```

- # adjacent_find
    > adjacent_find找出第一组满足条件的相邻元素

    ```C++
    template <typename ForwardIterator>
    ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {
        if (first == last)  return last;
        ForwardIterator next = first;
        while (++next != last) {
            if (*first == *next)    return first;
            first = next;
        }
        return last;
    }

    template <typename ForwardIterator, typename BinaryPredicate>
    ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred) {
        if (first == last)  return last;
        ForwardIterator next = first;
        while (++next != last) {
            if (binary_pred(*first, *next))    return first;
            first = next;
        }
        return last;
    }
    ```

- # set_symmetric_difference
    > set_symmetric_difference可构造S1、S2之对称差集。

    ```C++
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator>
    OutputInterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                                            InputIterator2 first2, InputIterator2 last2,
                                            OutputInterator result) {
        while (first1 != last1 && first2 != last2) {
            if (*first1 < *first2) {
                *result = *first1;
                ++first1;
                ++result;
            } else if (*first2 < *first1) {
                *result = *first2;
                ++first2;
                ++result;
            }
            else {
                ++first1;
                ++first2;
            }
        }
        return copy(first2, last2, copy(first1, last1, result));
    }
    ```

- # set_difference
    > set_difference可构造S1、S2之差集(S1有，S2无)。如果某值在S1中出现n次，在S2中出现m次，则该值在输出区间中会出现 max(n - m, 0) 次，并且全部来自S1。

    ```C++
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator>
    OutputInterator set_difference(InputIterator1 first1, InputIterator1 last1,
                                InputIterator2 first2, InputIterator2 last2,
                                OutputInterator result) {
        while (first1 != last1 && first2 != last2) {
            if (*first1 < *first2) {
                *result = *first1;
                ++first1;
                ++result;
            } else if (*first2 < *first1) 
                ++first2;
            else {
                ++first1;
                ++first2;
            }
        }
        return copy(first1, last1, result);
    }
    ```

- # set_intersection
    > set_intersection可构造S1、S2之交集。如果某值在S1中出现n次，在S2中出现m次，则该值在输出区间中会出现 min(m, n) 次，并且全部来自S1。

    ```C++
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator>
    OutputInterator set_intersection(InputIterator1 first1, InputIterator1 last1,
                                    InputIterator2 first2, InputIterator2 last2,
                                    OutputInterator result) {
        while (first1 != last1 && first2 != last2) {
            if (*first1 < *first2)
                ++first1;
            else if (*first2 < *first1)
                ++first2;
            else {
                *result = *first1; 
                ++first1; 
                ++first2; 
                ++result;
            }
        }
        return result;
    }
    ```

- # set_union
    > set_union可构造S1、S2之并集（S1,S2为两已排序的set集合）。如果某值在S1中出现n次，在S2中出现m次，则该值在输出区间中会出现 max(m, n) 次，其中n个来自S1，其余来自S2。

    ```C++
    template <typename InputIterator1, typename InputIterator2, typename OutputInterator>
    OutputInterator set_union(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            OutputInterator result) {
        while (first1 != last1 && first2 != last2) {
            if(*first1 < *first2) {
                *result = *first1;
                ++first1;
            } else if (*first2 < *first1) {
                *result = *first2;
                ++first2;
            } else {   //*first2 == *first1
                *result = *first1;
                ++first1;
                ++first2;
            }
            ++result;
        }
        return copy(first2, last2, copy(first1, last1, result));
    }
    ```

- # copy
    ```C++
    //完全泛化版本
    template <typename InputIterator, typename OutputIterator>
    inline OutputIterator copy(InputIterator first, InputIterator last,
                            OutputIterator result) {
        return __copy_dispatch<InputIterator, OutputIterator>()(first, last, result);
    }

    //重载
    inline char* copy(const char* first, const char* last,
                    char* result) {
        memmove(result, first, last - first);
        return result + (last - first); 
    }

    //重载
    inline wchar_t* copy(const wchar_t* first, const wchar_t* last,
                        wchar_t* result) {
        memmove(result, first, sizeof(wchar_t) * (last - first));
        return result + (last - first); 
    }

    ///完全泛化版本
    template <typename InputIterator, typename OutputIterator>
    struct __copy_dispatch{
        OutputIterator operator()(InputIterator first, InputIterator last,
                                OutputIterator result) {
            return __copy(first, last, result, iterator_category(first));
        }
    };

    //偏特化 T*
    template <typename T>
    struct __copy_dispatch<T*, T*>{
        T* operator()(T* first, T* last, T* result) {
            typedef typename __type_traits<T>::has_trivial_assignment_operator t;
            return __copy_t(first, last, result, t());
        }
    };

    //偏特化 const T*, T*
    template <typename T>
    struct __copy_dispatch<const T*, T*>{
        T* operator()(const T* first, const T* last, T* result) {
            typedef typename __type_traits<T>::has_trivial_assignment_operator t;
            return __copy_t(first, last, result, t());
        }
    };

    //InputIterator 版本
    template <typename InputIterator, typename OutputIterator>
    inline OutputIterator __copy(InputIterator first, InputIterator last,
                                OutputIterator result, input_iterator_tag) {
        //以迭代器等同与否，决定循环是否继续。速度慢。
        for ( ; first != last; ++result, ++first)
            *result = *first;
        return result;
    }

    //RandomAccessIterator 版本
    template <typename RandomAccessIterator, typename OutputInterator>
    inline OutputInterator __copy(RandomAccessIterator first, RandomAccessIterator last,
                                OutputInterator result, random_access_iterator_tag) {
        //又划分出一个函数，为的是其它地方也可以用到
        return __copy_d(first, last, result, distance_type(first));
    }

    template <typename RandomAccessIterator, typename OutputIterator, typename Distance>
    inline OutputIterator __copy_d(RandomAccessIterator first, RandomAccessIterator last,
                                OutputIterator result, Distance*) {
        //以n决定循环的执行次数。速度快。
        for (Distance n = last - first; n > 0; --n, ++result, ++first)
            *result = *first;
        return result;
    }

    //适用于 trivial assignment operator
    template <typename T>
    inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {
        memmove(result, first, sizeof(T) * (last - first));
        return result + (last - first);
    }

    //适用于 non-trivial assignment operator
    template <typename T>
    inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {
        return __copy_d(first, last, result, (ptrdiff_t*) 0);
    }
    ```


- # accumulate
    ```C++
    template <typename InputIterator, typename T>
    T accumulate(InputIterator first, InputIterator last, T init){
        for ( ; first != last; ++first)
            init += *first;         //将每个元素值累加到初值 init 身上    
        return init;
    }

    //版本二
    template <typename InputIterator, typename T, typename BinaryOperation>
    T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op){
        for ( ; first != last; ++first)
            init = binary_op(init, *first);     //对每一个元素执行二元操作
        return init;
    }
    ```
- # equal
    ```C++
    template <typename InputIterator1, typename InputIterator2>
    inline bool equal(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2) {
        for ( ; first1 != last1; ++first1, ++first2)
            if (*first1 != *first2)
                return false;
        return true;
    }

    template <typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
    inline bool equal(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, BinaryPredicate binary_pred) {
        for ( ; first1 != last1; ++first1, ++first2)
            if (!binary_pred(*first1, *first2))
                return false;
        return true;
    }  
    ```
- # fill
    ```C++
    template <typename ForwardIterator, typename T>
    void fill(ForwardIterator first, ForwardIterator last, const T& value) {
        for ( ; first != last; ++first)
            *first = value;
    }
    ```
- # fill_n
    ```C++
    template <typename OutputIterator, typename Size, typename T>
    OutputIterator fill_n(OutputIterator first, Size n, const T& value) {
        for ( ; n > 0; --n, ++first)
            *first = value;
        return first;
    }
    ```

- # iter_swap

    ```C++
    //将两个 ForwardIterators 所指的对象对调
    template <typename ForwardIterator1, typename ForwardIterator2>
    inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
        __iter_swap(a, b, value_type(a));
    }

    template <typename ForwardIterator1, typename ForwardIterator2, typename T>
    inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {
        T tmp = *a;
        *a = *b;
        *b = tmp;
    }

    template <typename Iterator>
    inline typename iterator_traits<Iterator>::value_type*
    value_type(const Iterator&) {
        return static_cast<typename iterator_traits<Iterator>::value_type*>(0);
    }
    ```
- # lexicographical_compare
    > 以“字典排序方式”依次对两个序列 [first1, last1) 和 [first2, last2) 进行比较，直到：（1）某一组对应元素彼此不相等；（2）同时到达 last1 和 last2 ；（3）到达 last1 或 last2。、
    - 如果第一序列的元素较小，返回 true。否则返回 false。
    - 如果到达 last1 而尚未到达 last2 ，返回 true。
    - 如果到达 last2 而尚未到达 last1 ，返回 false。
    - 如果同时到达 last1 和 last2 ，返回 false。
    ```C++
    template <typename InputInterator1, typename InputInterator2>
    bool lexicographical_compare(InputInterator1 first1, InputInterator1 last1,
                                 InputInterator2 first2, InputInterator2 last2) {
        for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {
            if (*first1 < *first2)  return true;
            if (*first2 < *first1)  return false;
        }
        return first1 == last1 && first2 != last2;
    }

    //第二版本
    template <typename InputInterator1, typename InputInterator2, typename Compare>
    bool lexicographical_compare(InputInterator1 first1, InputInterator1 last1,
                                 InputInterator2 first2, InputInterator2 last2,
                                 Compare comp) {
        for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {
            if (comp(*first1, *first2)) return true;
            if (comp(*first2, *first1)) return false;
        }
        return first1 == last1 && first2 != last2;
    } 

    //特化版本，用于原生指针 const unsigned char*
    inline bool lexicographical_compare(const unsigned char* first1, const unsigned char* last1,
                                        const unsigned char* first2, const unsigned char* last2) {
        const size_t len1 = last1 - first1;     //第一序列长度
        const size_t len2 = last2 - first2;     //第二序列长度
        //先比较相同长度的一段。memcmp() 速度极快
        const int result = memcmp(first1, first2, min(len1, len2));
        //如果不相上下，则长度较长者被视为较大
        return result != 0 ? result < 0 : len1 < len2;
    }
    ```
- # min
    ```C++
    //版本一
    template <typename T>
    inline const T& min(const T& a, const T& b) {
        return a < b ? a : b;
    }

    //版本二
    template <typename T, typename Compare>
    inline const T& min(const T& a, const T& b, Compare comp) {
        return comp(a, b) ? a : b;
    }
    ```

- # max
    ```C++
    //版本一
    template <typename T>
    inline const T& max(const T& a, const T& b) {
        return a > b ? a : b;
    }

    //版本二
    template <typename T, typename Compare>
    inline const T& max(const T& a, const T& b, Compare comp) {
        return comp(a, b) ? a : b;
    }
    ```

- # mismatch
    > 平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，若都匹配，则返回两序列各自的 last 迭代器。若第二序列的元素个数比第一序列多，多出来的忽略不计；若相反，会发生不可预期的行为。
    ```C++
    //版本一
    template <typename InputInterator1, typename InputInterator2>
    pair<InputInterator1, InputInterator2> mismatch(InputInterator1 first1, InputInterator1 last1,
                                                    InputInterator2 first2) {
        for ( ; first1 != last1 && *first1 == *first2; ++first1, ++first2);
        return pair<InputInterator1, InputInterator2>(first1, first2);
    }

    //版本二
    template <typename InputInterator1, typename InputInterator2, typename BinaryPredicate>
    pair<InputInterator1, InputInterator2> mismatch(InputInterator1 first1, InputInterator1 last1,
                                                    InputInterator2 first2,
                                                    BinaryPredicate binary_pred) {
        for ( ; first1 != last1 && binary_pred(*first1, *first2); ++first1, ++first2);
        return pair<InputInterator1, InputInterator2>(first1, first2);
    }
    ```
